/**
 * Generated by "@vuepress/internal-site-data"
 */
export const siteData = {
  "title": "Lemon",
  "description": "Lemon's blog",
  "base": "/",
  "pages": [
    {
      "title": "2. 两数相加",
      "frontmatter": {
        "date": "2019-09-12T00:00:00.000Z",
        "tag": [
          "leetcode",
          "链表"
        ],
        "author": "Lemon",
        "location": "Shanghai",
        "lang": "zh-CN",
        "layout": "Post",
        "permalink": "/:year/:month/:day/:slug"
      },
      "regularPath": "/_leetcode/2019-9-12-2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html",
      "relativePath": "_leetcode/2019-9-12-2. 两数相加.md",
      "key": "v-789a7aa8",
      "path": "/2019/09/12/_2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/",
      "headers": [
        {
          "level": 3,
          "title": "题目描述",
          "slug": "题目描述"
        },
        {
          "level": 3,
          "title": "解法",
          "slug": "解法"
        }
      ],
      "summary": "\n题目描述\n\n给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照   逆序   的方式存储的，并且它们的每个节点只能存储   一位   数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0  开头。\n\n示例：\n\n> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)< ...",
      "id": "leetcode",
      "pid": "leetcode"
    },
    {
      "title": "关于我",
      "frontmatter": {},
      "regularPath": "/about.html",
      "relativePath": "about.md",
      "key": "v-4543c549",
      "path": "/about.html",
      "summary": " ..."
    },
    {
      "title": "理解JavaScript中的闭包",
      "frontmatter": {
        "date": "2019-02-17T00:00:00.000Z",
        "tag": [
          "基础知识",
          "闭包"
        ],
        "author": "Lemon",
        "location": "Shanghai",
        "lang": "zh-CN",
        "layout": "Post",
        "permalink": "/:year/:month/:day/:slug"
      },
      "regularPath": "/_post/2019-02-17-%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html",
      "relativePath": "_post/2019-02-17-理解JavaScript中的闭包.md",
      "key": "v-0f5b088c",
      "path": "/2019/02/17/%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/",
      "headers": [
        {
          "level": 3,
          "title": "闭包的产生",
          "slug": "闭包的产生"
        },
        {
          "level": 3,
          "title": "闭包的应用",
          "slug": "闭包的应用"
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结"
        }
      ],
      "excerpt": "<h1 id=\"理解javascript中的闭包\"><a class=\"header-anchor\" href=\"#理解javascript中的闭包\" aria-hidden=\"true\">#</a> 理解JavaScript中的闭包</h1>\n<p>闭包不是我们需要学习的语法或者模式才能使用的工具，闭包是基于词法作用域书写代码是所产生的自然结果，闭包在我们所写的代码中随处可见。</p>\n<p>所以，什么是闭包呢？</p>\n",
      "summary": "\n\n闭包不是我们需要学习的语法或者模式才能使用的工具，闭包是基于词法作用域书写代码是所产生的自然结果，闭包在我们所写的代码中随处可见。\n\n所以，什么是闭包呢？\n\n> 闭包是指有权访问另一个函数作用域中的变量的函数。\n\n闭包的产生\n> 当函数可以记住并访问所在的词法作用域是，就产生了闭包，即使函数是在当前词法作用域之外执行。\n\n根据闭包的定义其实创建闭包最常用的方式 ...",
      "id": "post",
      "pid": "post"
    },
    {
      "title": "JavaScript函数的传参",
      "frontmatter": {
        "date": "2019-01-16T00:00:00.000Z",
        "tag": [
          "基础知识",
          "函数"
        ],
        "author": "Lemon",
        "location": "Shanghai",
        "lang": "zh-CN",
        "layout": "Post",
        "permalink": "/:year/:month/:day/:slug"
      },
      "regularPath": "/_post/2019-01-16-JavaScript%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%8F%82.html",
      "relativePath": "_post/2019-01-16-JavaScript函数的传参.md",
      "key": "v-1de21870",
      "path": "/2019/01/16/javascript%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%A0%E5%8F%82/",
      "headers": [
        {
          "level": 3,
          "title": "数据类型",
          "slug": "数据类型"
        },
        {
          "level": 3,
          "title": "函数的传参",
          "slug": "函数的传参"
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结"
        }
      ],
      "excerpt": "<h1 id=\"javascript函数的传参\"><a class=\"header-anchor\" href=\"#javascript函数的传参\" aria-hidden=\"true\">#</a> JavaScript函数的传参</h1>\n<p>JavaScript 中的函数传参是按值传递还是按引用传递呢？</p>\n<blockquote>\n<p>ECMAScript 中所有函数的参数都是按值传递的。\n<p align=\"right\"><font color=gray size=2>摘自 JavaScript高级程序设计</font></p></p>\n</blockquote>\n",
      "summary": "\n\nJavaScript 中的函数传参是按值传递还是按引用传递呢？\n> ECMAScript 中所有函数的参数都是按值传递的。\n摘自 JavaScript高级程序设计\n\n下面我们看一段代码\nfunction changeStuff(a, ...",
      "id": "post",
      "pid": "post"
    },
    {
      "title": "1. 两数之和",
      "frontmatter": {
        "date": "2019-09-07T00:00:00.000Z",
        "tag": [
          "leetcode"
        ],
        "author": "Lemon",
        "location": "Shanghai",
        "lang": "zh-CN",
        "layout": "Post",
        "permalink": "/:year/:month/:day/:slug"
      },
      "regularPath": "/_leetcode/2019-9-7-1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html",
      "relativePath": "_leetcode/2019-9-7-1. 两数之和.md",
      "key": "v-2ea38714",
      "path": "/2019/09/07/_1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/",
      "headers": [
        {
          "level": 3,
          "title": "题目描述",
          "slug": "题目描述"
        },
        {
          "level": 3,
          "title": "解法",
          "slug": "解法"
        }
      ],
      "summary": "\n题目描述\n\n给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例:\n\n> 给定 nums = [2, 7, 11, 15], target = 9  因为 nums[0] + nums[1] = ...",
      "id": "leetcode",
      "pid": "leetcode"
    },
    {
      "title": "理解JavaScript作用域",
      "frontmatter": {
        "date": "2018-12-10T00:00:00.000Z",
        "tag": [
          "基础知识",
          "作用域"
        ],
        "author": "Lemon",
        "location": "Shanghai",
        "lang": "zh-CN",
        "layout": "Post",
        "permalink": "/:year/:month/:day/:slug"
      },
      "regularPath": "/_post/2018-12-10-%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F.html",
      "relativePath": "_post/2018-12-10-理解JavaScript作用域.md",
      "key": "v-0ae0d2b6",
      "path": "/2018/12/10/%E7%90%86%E8%A7%A3javascript%E4%BD%9C%E7%94%A8%E5%9F%9F/",
      "headers": [
        {
          "level": 3,
          "title": "全局作用域",
          "slug": "全局作用域"
        },
        {
          "level": 3,
          "title": "函数作用域",
          "slug": "函数作用域"
        },
        {
          "level": 3,
          "title": "块作用域",
          "slug": "块作用域"
        },
        {
          "level": 3,
          "title": "作用域链",
          "slug": "作用域链"
        },
        {
          "level": 3,
          "title": "一个面试题",
          "slug": "一个面试题"
        },
        {
          "level": 3,
          "title": "总结",
          "slug": "总结"
        }
      ],
      "excerpt": "<h1 id=\"理解javascript作用域\"><a class=\"header-anchor\" href=\"#理解javascript作用域\" aria-hidden=\"true\">#</a> 理解JavaScript作用域</h1>\n<p>JavaScript 定义了一套如何存储以及查找变量的规则，这套规则就是<strong>作用域</strong>。</p>\n<p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域。JavaScript 采用的就是词法作用域。</p>\n<p>作用域主要有全局作用域、函数作用域以及 ES6 新增的块级作用域。</p>\n",
      "summary": "\n\nJavaScript 定义了一套如何存储以及查找变量的规则，这套规则就是作用域。\n\n作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域。JavaScript 采用的就是词法作用域。\n\n作用域主要有全局作用域、函数作用域以及 ES6 新增的块级作用域。\n\n下面我们详细的了解一下上面介绍的作用域。\n ...",
      "id": "post",
      "pid": "post"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Post"
      },
      "regularPath": "/",
      "key": "v-b2754d56",
      "path": "/"
    },
    {
      "frontmatter": {
        "layout": "Layout",
        "title": "Leetcode"
      },
      "regularPath": "/leetcode/",
      "key": "v-02951176",
      "path": "/leetcode/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterKey",
        "title": "Tag"
      },
      "regularPath": "/tag/",
      "key": "v-b1564aac",
      "path": "/tag/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterPagination",
        "title": "leetcode tag"
      },
      "regularPath": "/tag/leetcode/",
      "key": "v-4d69a590",
      "path": "/tag/leetcode/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterPagination",
        "title": "链表 tag"
      },
      "regularPath": "/tag/%E9%93%BE%E8%A1%A8/",
      "key": "v-38874a70",
      "path": "/tag/链表/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterPagination",
        "title": "基础知识 tag"
      },
      "regularPath": "/tag/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
      "key": "v-b11fcc4c",
      "path": "/tag/基础知识/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterPagination",
        "title": "闭包 tag"
      },
      "regularPath": "/tag/%E9%97%AD%E5%8C%85/",
      "key": "v-eec8ec48",
      "path": "/tag/闭包/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterPagination",
        "title": "函数 tag"
      },
      "regularPath": "/tag/%E5%87%BD%E6%95%B0/",
      "key": "v-5c9b2e55",
      "path": "/tag/函数/"
    },
    {
      "frontmatter": {
        "layout": "FrontmatterPagination",
        "title": "作用域 tag"
      },
      "regularPath": "/tag/%E4%BD%9C%E7%94%A8%E5%9F%9F/",
      "key": "v-381c6bfb",
      "path": "/tag/作用域/"
    }
  ],
  "themeConfig": {
    "nav": [
      {
        "text": "Blog",
        "link": "/"
      },
      {
        "text": "LeetCode",
        "link": "/leetcode/"
      },
      {
        "text": "Tag",
        "link": "/tag/"
      },
      {
        "text": "About",
        "link": "/about"
      },
      {
        "text": "Github",
        "link": "https://github.com/volcanoliuc"
      }
    ]
  }
}